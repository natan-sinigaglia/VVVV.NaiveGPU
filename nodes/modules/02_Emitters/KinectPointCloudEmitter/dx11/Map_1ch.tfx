//@author: dottore
//@help: map incoming Texture channels
//@tags: GEA
//@credits: 

Texture2D texture2d : PREVIOUS;

SamplerState linearSampler : IMMUTABLE
{
    Filter = MIN_MAG_MIP_LINEAR;
    AddressU = Clamp;
    AddressV = Clamp;
};

float sourceOffset;
float sourceMin = 0;
float sourceMax = 1;
float gamma = 1;
bool invert;
float destinationMin = 0;
float destinationMax = 1;

// =============================================================================
// PS ==========================================================================
// =============================================================================

struct psInput
{
	float4 p : SV_Position;
	float2 uv : TEXCOORD0;
};


float PS_Float(psInput In) : SV_Target
{
	float input = texture2d.Sample(linearSampler,In.uv).x + sourceOffset;
	
	// MAP:
	float range = sourceMax - sourceMin;
	float normalized = (input - sourceMin) / range;
	
	int s = sign(normalized);
	float output =  pow(abs(normalized), gamma);
	output *= s;
	
	//output = normalized;
	
	if(invert) output = 1-output;
	
	float outRange = destinationMax - destinationMin;
	output = (output * outRange) + destinationMin;
	
	return output;		
}

float PS_Wrap(psInput In) : SV_Target
{
	float input = texture2d.Sample(linearSampler,In.uv).x + sourceOffset;
	
	// MAP:
	float range = sourceMax - sourceMin;
	float normalized = (input - sourceMin) / range;
	if (normalized < 0)
	normalized = 1 + normalized;
	
	float output = pow(frac(normalized), gamma);

	if(invert) output = 1-output;

	float outRange = destinationMax - destinationMin;
	output = (output * outRange) + destinationMin;

	return output;
}

float PS_Mirror(psInput In) : SV_Target
{
	float input = texture2d.Sample(linearSampler,In.uv).x + sourceOffset;
	
	// MAP:
	float range = sourceMax - sourceMin;
	float normalized = (input - sourceMin) / range;
	float output;
	if(fmod(abs(floor(normalized)),2) > 0)
	output =  1-frac(normalized);
	else	output =  frac(normalized);	

	output = pow(output, gamma);

	if(invert) output = 1-output;

	float outRange = destinationMax - destinationMin;
	output = (output * outRange) + destinationMin;

   	return output;
}

float PS_Clamp(psInput In) : SV_Target
{
	float input = texture2d.Sample(linearSampler,In.uv).x + sourceOffset;
	
	// MAP:
	float range = sourceMax - sourceMin;
	float normalized = (input - sourceMin) / range;
	float output = saturate(normalized);	

	output = pow(output, gamma);

	if(invert) output = 1-output;

	float outRange = destinationMax - destinationMin;
	output = (output * outRange) + destinationMin;

	return output;
}

// =============================================================================
// TECHNIQUES ==================================================================
// =============================================================================

technique11 Float
{
	pass P0  <string format="R32_Float"; >
	{
		SetPixelShader(CompileShader(ps_5_0,PS_Float()));
	}
}

technique11 Wrap
{
	pass P0  <string format="R32_Float"; >
	{
		SetPixelShader(CompileShader(ps_5_0,PS_Wrap()));
	}
}

technique11 Mirror
{
	pass P0  <string format="R32_Float"; >
	{
		SetPixelShader(CompileShader(ps_5_0,PS_Mirror()));
	}
}

technique11 Clamp
{
	pass P0  <string format="R32_Float"; >
	{
		SetPixelShader(CompileShader(ps_5_0,PS_Clamp()));
	}
}



