#ifndef SBUFFER_FXH
#include <packs\happy.fxh\sbuffer.fxh>
#endif

#ifndef TUBE_RES
#define TUBE_RES 8
#endif

#include "StageStructs.fxh"

//3d spline with tangents
struct SplinePosTan3
{
	float3 Pos;
	float3 Tang;
};

SplinePosTan3 BSplineCubic3PT(float3 p1, float3 p2, float3 p3, float3 p4, float range) 
{
	SplinePosTan3 Out = (SplinePosTan3)0;

    float mu = frac(range);
   	float3 a0 = p4 - p3*3 + p2*3 - p1;
   	float3 a1 = p3*3 - p2*6 + p1*3.;
	float3 a2 = p3*3 - p1*3;
   	float3 a3 = p3 + p2*4 + p1;
	
	Out.Pos = (a3+mu*(a2+mu*(a1+mu*a0)))/6.;
	Out.Tang = (mu*(2*a0*mu+a1)+mu*(a0*mu+a1)+a2)/6.;
	return Out;
}


float BSplineCubic(float p1, float p2, float p3, float p4, float range)
{
    float mu = frac(range);
   	float a0 = p4 - p3*3 + p2*3 - p1;
   	float a1 = p3*3 - p2*6 + p1*3.;
	float a2 = p3*3 - p1*3;
   	float a3 = p3 + p2*4 + p1;
	
	return (a3+mu*(a2+mu*(a1+mu*a0)))/6.;
}

float4x4 tWVP:WORLDVIEWPROJECTION;
float4x4 tVP:VIEWPROJECTION;
float4x4 tW:WORLD;
float4x4 tV:VIEW;
float4x4 tP:PROJECTION;
float4x4 tWI:WORLDINVERSE;
float4x4 tVI:VIEWINVERSE;
float4x4 tPI:PROJECTIONINVERSE;
float4x4 tWIT:WORLDINVERSETRANSPOSE;



//spline parameters
StructuredBuffer<float4> ControlPointBuffer;
uint IndexOffset;

int VertexPerSpline=16;
int ControlPointPerSpline=2;
bool Loop=0;
float TesselationFactor <float uimin=1.0;float uimax=64.0;> = 1;
float Radius=0.5;

float SplinesCount;

StructuredBuffer<float>sbRadius;

interface iSplineWidth
{
   float Get(float splineID, int offset, int startctrl, int endctrl, float range);
};
class cPerSpline : iSplineWidth    // width is per spline 
{
    float Get(float splineID, int offset, int startctrl, int endctrl, float range)
	{
		return sbLoad(sbRadius,Radius,splineID);
	}
}; 

class cPerSegment : iSplineWidth    // sample width over contorl points
{
   float Get(float splineID, int offset, int startctrl, int endctrl, float range)
	{
		if(Loop)
		{
			float c1 = sbLoad(sbRadius,Radius,(range-1)%(uint)ControlPointPerSpline+offset);
			float c2 = sbLoad(sbRadius,Radius,(range-0)%(uint)ControlPointPerSpline+offset);
			float c3 = sbLoad(sbRadius,Radius,(range+1)%(uint)ControlPointPerSpline+offset);
			float c4 = sbLoad(sbRadius,Radius,(range+2)%(uint)ControlPointPerSpline+offset);
			return BSplineCubic(c1,c2,c3,c4,range);
		}
		else
		{
			float c1 = sbLoad(sbRadius,Radius, clamp(range-1,startctrl,endctrl)+offset);
			float c2 = sbLoad(sbRadius,Radius, clamp(range-0,startctrl,endctrl)+offset);
			float c3 = sbLoad(sbRadius,Radius, clamp(range+1,startctrl,endctrl)+offset);
			float c4 = sbLoad(sbRadius,Radius, clamp(range+2,startctrl,endctrl)+offset);
			return BSplineCubic(c1,c2,c3,c4,range);
		}
		

	}
}; 
cPerSpline Spline;
cPerSegment Segment;

iSplineWidth widthIndexing <string linkclass="Spline,Segment";>;


StructuredBuffer<float4x4>sbTexTransform;
StructuredBuffer<float4x4>sbTransform;
float4x4 dMat;
float4x4 dTMat;
float TangentEpsilon=.01;
float3 UpVector={0,1,0};

//SPLINE DISTORT FUNCTION

float3 dist(float3 pos,int splineid=0,float t=0){
	float3 p=pos;
	p=mul(float4(p.xyz,1),sbLoad(sbTransform, dMat,splineid)).xyz;

	return p;
}


//TESSELATION SETUP
VS_OUT VS(VS_IN In){VS_OUT p;p.iv=In.iv;return p;}
HSC_OUT HSConst(){HSC_OUT Out;Out.edges[0]=1.0f;Out.edges[1]=TesselationFactor;return Out;}
[domain("isoline")][partitioning("fractional_even")][outputtopology("line")][outputcontrolpoints(1)][patchconstantfunc("HSConst")]
VS_OUT HS(InputPatch<VS_OUT, 1> ip, uint id : SV_OutputControlPointID){VS_OUT output;output.iv=ip[0].iv;return output;}


[domain("isoline")]
GS_IN DS(HSC_OUT hsc, OutputPatch<VS_OUT, 1> In, float2 uv : SV_DomainLocation)
{
    GS_IN Out;
	//Retrieve spline id and vertex id
	int splineid = In[0].iv / VertexPerSpline;	
	int segmentid = In[0].iv % VertexPerSpline;
	
	//That's the control point range in the buffer
	int offset=splineid * ControlPointPerSpline;
	//int startctrl = splineid * ControlPointPerSpline;
	//int endctrl = startctrl + ControlPointPerSpline -1;
	int startctrl = 0;
	int endctrl = ControlPointPerSpline -1;
	
	//number between 0 and 1 generated by tesselator
	float t = uv.x;
	 
	//Rebuild with segment ids
	float segmentsize = 1.0f / (float)VertexPerSpline;
	t *= segmentsize;
	t += segmentsize * (float)segmentid;

	
	SplinePosTan3 sp=(SplinePosTan3)0;

	//That will be nearest control point
	//int t2 = floor(t*ControlPointPerSpline) + startctrl;
	int cpBufferSize = sbSize(ControlPointBuffer);
	int t2 = (t*ControlPointPerSpline);
	//Grab four control points around our coordinate
	float3 c1 = ControlPointBuffer[clamp(t2-1,startctrl,endctrl)+IndexOffset+offset % cpBufferSize].xyz;
	float3 c2 = ControlPointBuffer[clamp(t2-0,startctrl,endctrl)+IndexOffset+offset % cpBufferSize].xyz;
	float3 c3 = ControlPointBuffer[clamp(t2+1,startctrl,endctrl)+IndexOffset+offset % cpBufferSize].xyz;
	float3 c4 = ControlPointBuffer[clamp(t2+2,startctrl,endctrl)+IndexOffset+offset % cpBufferSize].xyz;
	//Compute spline equation (which has derivative for normal and other bits)
	sp = BSplineCubic3PT(c1,c2,c3,c4,t*ControlPointPerSpline);
	
	
	if(Loop){
	t2+=ControlPointPerSpline;
	float3 c1 = ControlPointBuffer[(t2-1)%(uint)ControlPointPerSpline+IndexOffset+offset % cpBufferSize].xyz;
	float3 c2 = ControlPointBuffer[(t2-0)%(uint)ControlPointPerSpline+IndexOffset+offset % cpBufferSize].xyz;
	float3 c3 = ControlPointBuffer[(t2+1)%(uint)ControlPointPerSpline+IndexOffset+offset % cpBufferSize].xyz;
	float3 c4 = ControlPointBuffer[(t2+2)%(uint)ControlPointPerSpline+IndexOffset+offset % cpBufferSize].xyz;
	sp = BSplineCubic3PT(c1,c2,c3,c4,t*ControlPointPerSpline);
	}
	
	float3 p=sp.Pos.xyz;
	
	sp.Pos.xyz=dist(sp.Pos.xyz,splineid,t);
	sp.Tang.xyz=dist(p+normalize(sp.Tang)*TangentEpsilon,splineid,t)-sp.Pos.xyz;
	float width = widthIndexing.Get(splineid, offset,  startctrl,  endctrl,  t*ControlPointPerSpline);
    Out.Pos = float4(sp.Pos.xyz, width);
	Out.Dir = normalize(sp.Tang);
	Out.TexCd=float2(t,0);
	if(!Loop)Out.TexCd.y=t>segmentsize*(VertexPerSpline)*(1-0.25/(VertexPerSpline*TesselationFactor));
	Out.si=splineid;
	
    return Out;
}



void GS_TubePoint( float3x3 m, GS_IN In, int i,float2 TexCd, inout TriangleStream<GS_OUT>GSOut)
{
	GS_OUT Out;
	//float4x4 tRing=sbRing[In.si%RingTransformCount];
	//float4x4 tRingIT=sbRingIT[In.si%RingTransformCount];
	float fRad=In.Pos.w;
	float3 ring=float3(sin(((float)i/TUBE_RES-.5/TUBE_RES+float2(-.25,0))*acos(-1)*2).xy,0);
	
	//float3 pos = (mul(mul(float4(ring * fRad,1),tRing).xyz,m ));
	//float3 norm = normalize(mul(mul(float4(ring,1),tRingIT).xyz,m ));
	float3 pos = mul(ring * fRad, m);
	float3 norm = normalize(mul(ring,m));
	
	//norm = mul(float4(norm,0),tWIT).xyz;
	pos += In.Pos.xyz;
	//Out.PosWVP = mul( float4(pos,1), tWVP );
	Out.PosWVP=float4(pos,1);
	Out.Norm = norm;
	//Out.TexCd.xy=mul(float4((TexCd.xy*2-1)*float2(1,-1),0,1), sbLoad(sbTexTransform, dTMat, In.si)).xy*float2(1,-1)*.5+.5;
	Out.TexCd.xy = float2(TexCd.x, (float)In.si/SplinesCount + 0.5/SplinesCount);

	Out.iid=In.si;
	GSOut.Append(Out);
}
//*
#define TUBE_RES_SQ 4
void GS_TubePointSQ( float3x3 m, GS_IN In, int i, int ni,float2 TexCd, inout TriangleStream<GS_OUT>GSOut)
{
	GS_OUT Out;
	//float4x4 tRing=sbRing[In.si%RingTransformCount];
	//float4x4 tRingIT=sbRingIT[In.si%RingTransformCount];
	float fRad=In.Pos.w;
	float3 ring=float3(sin(((float)i/TUBE_RES_SQ-.5/TUBE_RES_SQ+float2(-.25,0))*acos(-1)*2).xy,0);
	float3 ring2=float3(sin(((float)(ni+0.5)/TUBE_RES_SQ+float2(-.25,0))*acos(-1)*2).xy,0);
	
	//float3 pos = (mul(mul(float4(ring * fRad,1),tRing).xyz,m ));
	//float3 norm = normalize(mul(mul(float4(ring2,1),tRingIT).xyz,m));
	float3 pos = mul(ring * fRad, m);
	float3 norm = normalize(mul(ring2,m));
	
	norm = mul(float4(norm,0),tWIT).xyz;
	pos += In.Pos.xyz;
	//Out.PosWVP = mul( float4(pos,1), tWVP );
	Out.PosWVP=float4(pos,1);
	Out.Norm = norm;
	Out.TexCd.xy=mul(float4((TexCd.xy*2-1)*float2(1,-1),0,1), sbLoad(sbTexTransform, dTMat, In.si)).xy*float2(1,-1)*.5+.5;
	Out.iid=In.si;
	GSOut.Append(Out);
}

#define TUBE_RES_SQ2 2
void GS_TubePointFlat( float3x3 m, GS_IN In, int i, int ni,float2 TexCd, inout TriangleStream<GS_OUT>GSOut)
{
	GS_OUT Out;
	//float4x4 tRing=sbRing[In.si%RingTransformCount];
	//float4x4 tRingIT=sbRingIT[In.si%RingTransformCount];
	float fRad=In.Pos.w;
	float3 ring=float3(sin(((float)i/TUBE_RES_SQ2-.5/TUBE_RES_SQ2+float2(0,0))*acos(-1)*2).xy,0);
	float3 ring2=float3(sin(((float)(ni+0.5)/TUBE_RES_SQ2+float2(0,0))*acos(-1)*2).xy,0);
	
	//float3 pos = (mul(mul(float4(ring * fRad,1),tRing).xyz,m ));
	//float3 norm = normalize(mul(mul(float4(ring2,1),tRingIT).xyz,m));
	float3 pos = mul(ring * fRad, m);
	float3 norm = normalize(mul(ring2,m));
	
	norm = mul(float4(norm,0),tWIT).xyz;
	pos += In.Pos.xyz;
	//Out.PosWVP = mul( float4(pos,1), tWVP );
	Out.PosWVP=float4(pos,1);
	Out.Norm = norm;
	Out.TexCd.xy=mul(float4((TexCd.xy*2-1)*float2(1,-1),0,1), sbLoad(sbTexTransform, dTMat, In.si)).xy*float2(1,-1)*.5+.5;
	Out.iid=In.si;
	GSOut.Append(Out);
}

float3x3 lookat(float3 dir,float3 up=float3(0,1,0)){float3 z=normalize(dir);float3 x=normalize(cross(up,z));float3 y=normalize(cross(z,x));return float3x3(x,y,z);} 

[maxvertexcount((TUBE_RES+1)*2)]
void gsTUBE(line GS_IN In[2], inout TriangleStream<GS_OUT>GSOut){
	if(In[1].TexCd.y==1)return;
	float3 up=UpVector;
	//up=mul(float3(0,0,1),(float3x3)tVI);

	float3x3 m0=lookat(In[0].Dir,up);
	float3x3 m1=lookat(In[1].Dir,up);

	for(int i=0; i < TUBE_RES + 1; i++){
		GS_TubePoint( m0, In[0], i,float2(In[0].TexCd.x,(float)i/TUBE_RES), GSOut );
		GS_TubePoint( m1, In[1], i,float2(In[1].TexCd.x,(float)i/TUBE_RES), GSOut );
	}
	GSOut.RestartStrip();
}
//*

[maxvertexcount((TUBE_RES_SQ)*4)]
void gsTUBESQ(line GS_IN In[2], inout TriangleStream<GS_OUT>GSOut){
	if(In[1].TexCd.y==1)return;
	float3 up=UpVector;
	//up=mul(float3(0,0,1),(float3x3)tVI);
	
	float3x3 m0=lookat(In[0].Dir,up);
	float3x3 m1=lookat(In[1].Dir,up);

    for(int i=0; i < TUBE_RES_SQ; i++){
		GS_TubePointSQ( m0, In[0], i,i,float2(In[0].TexCd.x,(float)i/TUBE_RES_SQ), GSOut );
		GS_TubePointSQ( m1, In[1], i,i,float2(In[1].TexCd.x,(float)i/TUBE_RES_SQ), GSOut );
		
		GS_TubePointSQ( m0, In[0], i+1,i,float2(In[0].TexCd.x,(float)(i+1)/TUBE_RES_SQ), GSOut );
    	GS_TubePointSQ( m1, In[1], i+1,i,float2(In[1].TexCd.x,(float)(i+1)/TUBE_RES_SQ), GSOut );
		GSOut.RestartStrip();
	}

	
    GSOut.RestartStrip();
}

[maxvertexcount((TUBE_RES_SQ))]
void gsTUBEFLAT(line GS_IN In[2], inout TriangleStream<GS_OUT>GSOut){
	if(In[1].TexCd.y==1)return;
	float3 up=UpVector;
	//up=mul(float3(0,0,1),(float3x3)tVI);
	
	float3x3 m0=lookat(In[0].Dir,up);
	float3x3 m1=lookat(In[1].Dir,up);

    for(int i=0; i < TUBE_RES_SQ; i++){
		GS_TubePointFlat( m0, In[0], i,i,float2(In[0].TexCd.x,(float)i/TUBE_RES_SQ), GSOut );
		GS_TubePointFlat( m1, In[1], i,i,float2(In[1].TexCd.x,(float)i/TUBE_RES_SQ), GSOut );
		
		GS_TubePointFlat( m0, In[0], i+1,i,float2(In[0].TexCd.x,(float)(i+1)/TUBE_RES_SQ), GSOut );
    	GS_TubePointFlat( m1, In[1], i+1,i,float2(In[1].TexCd.x,(float)(i+1)/TUBE_RES_SQ), GSOut );
		GSOut.RestartStrip();
	}

	
    GSOut.RestartStrip();
}
GeometryShader SO_GS_TUBE=ConstructGSWithSO(CompileShader(gs_5_0,gsTUBE()),"SV_Position.xyz;NORMAL.xyz;TEXCOORD0.xy;IID.x");
technique11 Tube{
	pass P0{
		SetHullShader( CompileShader( hs_5_0, HS() ) );
		SetDomainShader( CompileShader( ds_5_0, DS() ) );
		SetVertexShader( CompileShader( vs_5_0, VS() ) );
		SetGeometryShader(CompileShader(gs_5_0,gsTUBE()));
	    SetGeometryShader(SO_GS_TUBE);
	}
}
GeometryShader SO_GS_TUBESQ=ConstructGSWithSO(CompileShader(gs_5_0,gsTUBESQ()),"SV_Position.xyz;NORMAL.xyz;TEXCOORD0.xy;IID.x");
technique11 TubeSquare{
	pass P0{
		SetHullShader( CompileShader( hs_5_0, HS() ) );
		SetDomainShader( CompileShader( ds_5_0, DS() ) );
		SetVertexShader( CompileShader( vs_5_0, VS() ) );
		SetGeometryShader(CompileShader(gs_5_0,gsTUBESQ()));
	    SetGeometryShader(SO_GS_TUBESQ);
	}
}

GeometryShader SO_GS_TUBEFLAT=ConstructGSWithSO(CompileShader(gs_5_0,gsTUBEFLAT()),"SV_Position.xyz;NORMAL.xyz;TEXCOORD0.xy;IID.x");
technique11 Ribbon{
	pass P0{
		SetHullShader( CompileShader( hs_5_0, HS() ) );
		SetDomainShader( CompileShader( ds_5_0, DS() ) );
		SetVertexShader( CompileShader( vs_5_0, VS() ) );
		SetGeometryShader(CompileShader(gs_5_0,gsTUBEFLAT()));
	    SetGeometryShader(SO_GS_TUBEFLAT);
	}
}
